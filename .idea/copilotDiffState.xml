<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="updatedContent" value="pyfluidsynth&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/music_teacher/core/app.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/music_teacher/core/app.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Main application module for the Music Teacher application.&#10;&#10;This module serves as the primary entry point for the Music Teacher app.&#10;It initializes the PyGame environment, sets up the components, and runs the main loop.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import pygame&#10;import mido&#10;import threading&#10;import math&#10;from typing import Optional, Dict, Any&#10;from ..ui.visual import draw_piano, draw_ui_overlay, BG_COLOR, draw_guided_mode_overlay&#10;from ..audio.synth import Synth, PEDAL_CC&#10;from .midi_teach import MidiTeacher&#10;from ..ui.sheet_music import SheetMusicRenderer&#10;from .guided_teacher import GuidedTeacher&#10;from ..utils.save_system import SaveSystem&#10;&#10;LOWEST_NOTE = 21  # A0&#10;HIGHEST_NOTE = 108  # C8&#10;TOTAL_KEYS = HIGHEST_NOTE - LOWEST_NOTE + 1&#10;SOUNDFONT_PATH = &quot;/home/u200b/Music/Sound fonts/GeneralUser-GS.sf2&quot;&#10;&#10;# Defer blocking/heavy initialization to init_app()&#10;screen: Optional[pygame.Surface] = None&#10;clock: Optional[pygame.time.Clock] = None&#10;SCREEN_WIDTH: Optional[int] = None&#10;SCREEN_HEIGHT: Optional[int] = None&#10;WHITE_KEY_WIDTH: Optional[float] = None&#10;WHITE_KEY_HEIGHT: Optional[int] = None&#10;BLACK_KEY_WIDTH: Optional[float] = None&#10;BLACK_KEY_HEIGHT: Optional[float] = None&#10;PEDAL_WIDTH: Optional[int] = None&#10;PEDAL_HEIGHT: Optional[int] = None&#10;PEDAL_SPACING: Optional[int] = None&#10;PEDAL_Y: Optional[int] = None&#10;PIANO_Y_OFFSET: Optional[int] = None&#10;SHEET_Y: Optional[int] = None&#10;&#10;pressed_keys: Dict[int, bool] = {}&#10;pressed_fade_keys: Dict[int, int] = {}&#10;pedals: Dict[str, bool] = {&quot;soft&quot;: False, &quot;sostenuto&quot;: False, &quot;sustain&quot;: False}&#10;synth_enabled: bool = True&#10;teaching_mode: bool = True&#10;guided_mode: bool = False&#10;pressed_notes_set: set[int] = set()&#10;all_midi_events: list[Any] = []&#10;&#10;total_keys = TOTAL_KEYS&#10;&#10;piano_y_default: Optional[float] = None&#10;piano_y_center: Optional[float] = None&#10;piano_y_current: Optional[float] = None&#10;piano_y_target: Optional[float] = None&#10;&#10;overlay_alpha_current: Optional[float] = None&#10;overlay_alpha_target: Optional[float] = None&#10;sheet_alpha_current: Optional[float] = None&#10;sheet_alpha_target: Optional[float] = None&#10;piano_tau = 0.12&#10;alpha_tau = 0.18&#10;&#10;last_time_ms: Optional[int] = None&#10;&#10;dims: Dict[str, Any] = {}&#10;&#10;font_small: Optional[pygame.font.Font] = None&#10;font_medium: Optional[pygame.font.Font] = None&#10;&#10;# placeholders for objects that will be created during init&#10;save_system: Optional[SaveSystem] = None&#10;midi_path: Optional[str] = None&#10;state_lock: Optional[threading.Lock] = None&#10;synth: Optional[Synth] = None&#10;sheet_music_renderer: Optional[SheetMusicRenderer] = None&#10;midi_teacher: Optional[MidiTeacher] = None&#10;guided_teacher: Optional[GuidedTeacher] = None&#10;&#10;&#10;def save_all():&#10;    try:&#10;        # Be defensive: save_system and guided_teacher may be None if called before init_app()&#10;        if save_system is None and guided_teacher is None:&#10;            return&#10;        if save_system is not None:&#10;            save_system.save_midi(midi_path)&#10;        if guided_teacher is not None:&#10;            guided_teacher.save_state(force=True)&#10;    except Exception as e:&#10;        print(f&quot;Failed to save state: {e}&quot;)&#10;&#10;&#10;# Move blocking and heavy initialization into this function so module import is fast.&#10;# This sets up pygame, display, fonts, save system (and its MIDI prompt), synth,&#10;# sheet music renderer, midi teacher and guided teacher.&#10;def init_app():&#10;    global screen, clock, SCREEN_WIDTH, SCREEN_HEIGHT&#10;    global WHITE_KEY_WIDTH, WHITE_KEY_HEIGHT, BLACK_KEY_WIDTH, BLACK_KEY_HEIGHT&#10;    global PEDAL_WIDTH, PEDAL_HEIGHT, PEDAL_SPACING, PEDAL_Y, PIANO_Y_OFFSET, SHEET_Y&#10;    global piano_y_default, piano_y_center, piano_y_current, piano_y_target&#10;    global overlay_alpha_current, overlay_alpha_target, sheet_alpha_current, sheet_alpha_target&#10;    global last_time_ms, dims, font_small, font_medium&#10;    global save_system, midi_path, state_lock, synth, sheet_music_renderer, midi_teacher, guided_teacher&#10;&#10;    pygame.init()&#10;    info = pygame.display.Info()&#10;    SCREEN_WIDTH, SCREEN_HEIGHT = info.current_w, info.current_h&#10;    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))&#10;    pygame.display.set_caption(&quot;MIDI Piano Visualizer&quot;)&#10;    clock = pygame.time.Clock()&#10;&#10;    WHITE_KEY_WIDTH = SCREEN_WIDTH / 52&#10;    WHITE_KEY_HEIGHT = int(WHITE_KEY_WIDTH * 7)&#10;    BLACK_KEY_WIDTH = WHITE_KEY_WIDTH * 0.6&#10;    BLACK_KEY_HEIGHT = WHITE_KEY_HEIGHT * 0.65&#10;    PEDAL_WIDTH = int(WHITE_KEY_WIDTH * 1.2)&#10;    PEDAL_HEIGHT = int(WHITE_KEY_HEIGHT * 0.6)&#10;    PEDAL_SPACING = int(WHITE_KEY_WIDTH * 0.2)&#10;    SHEET_Y = 24 + 28 + 64&#10;    PIANO_Y_OFFSET = SHEET_Y + WHITE_KEY_HEIGHT + PEDAL_HEIGHT&#10;    PEDAL_Y = PIANO_Y_OFFSET + WHITE_KEY_HEIGHT + 30&#10;&#10;    piano_y_default = PIANO_Y_OFFSET&#10;    piano_y_center = (SCREEN_HEIGHT - WHITE_KEY_HEIGHT - PEDAL_HEIGHT) // 2&#10;    piano_y_current = float(piano_y_default)&#10;    piano_y_target = float(piano_y_default)&#10;&#10;    overlay_alpha_current = 1.0 if teaching_mode else 0.0&#10;    overlay_alpha_target = overlay_alpha_current&#10;    sheet_alpha_current = 1.0 if teaching_mode else 0.0&#10;    sheet_alpha_target = sheet_alpha_current&#10;&#10;    last_time_ms = pygame.time.get_ticks()&#10;&#10;    dims = {&#10;        &quot;SCREEN_WIDTH&quot;: SCREEN_WIDTH,&#10;        &quot;SCREEN_HEIGHT&quot;: SCREEN_HEIGHT,&#10;        &quot;WHITE_KEY_WIDTH&quot;: WHITE_KEY_WIDTH,&#10;        &quot;WHITE_KEY_HEIGHT&quot;: WHITE_KEY_HEIGHT,&#10;        &quot;BLACK_KEY_WIDTH&quot;: BLACK_KEY_WIDTH,&#10;        &quot;BLACK_KEY_HEIGHT&quot;: BLACK_KEY_HEIGHT,&#10;        &quot;PEDAL_WIDTH&quot;: PEDAL_WIDTH,&#10;        &quot;PEDAL_HEIGHT&quot;: PEDAL_HEIGHT,&#10;        &quot;PEDAL_SPACING&quot;: PEDAL_SPACING,&#10;        &quot;PEDAL_Y&quot;: PEDAL_Y,&#10;        &quot;LOWEST_NOTE&quot;: LOWEST_NOTE,&#10;        &quot;HIGHEST_NOTE&quot;: HIGHEST_NOTE,&#10;        &quot;PIANO_Y_OFFSET&quot;: PIANO_Y_OFFSET,&#10;        &quot;SHEET_Y&quot;: SHEET_Y,&#10;    }&#10;&#10;    font_small = pygame.font.SysFont(&quot;Segoe UI&quot;, 16)&#10;    font_medium = pygame.font.SysFont(&quot;Segoe UI&quot;, 20, bold=True)&#10;&#10;    save_system = SaveSystem(before_exit_callback=save_all)&#10;    midi_path = save_system.load_midi_path() or input(&quot;Enter path to MIDI file: &quot;).strip()&#10;    state_lock = threading.Lock()&#10;&#10;    # Create synth, renderers and teacher objects (may load files / be heavy)&#10;    synth = Synth(SOUNDFONT_PATH, render)&#10;    sheet_music_renderer = SheetMusicRenderer(&#10;        midi_path, SCREEN_WIDTH, save_system=save_system&#10;    )&#10;    midi_teacher = MidiTeacher(midi_path, sheet_music_renderer, save_system=save_system)&#10;    guided_teacher = GuidedTeacher(midi_teacher, synth, save_system=save_system)&#10;&#10;&#10;def render():&#10;    global \&#10;        last_time_ms, \&#10;        piano_y_current, \&#10;        piano_y_target, \&#10;        overlay_alpha_current, \&#10;        overlay_alpha_target, \&#10;        sheet_alpha_current, \&#10;        sheet_alpha_target&#10;&#10;    # If init_app() hasn't been run yet, don't attempt to render.&#10;    if screen is None or last_time_ms is None:&#10;        return&#10;&#10;    now_ms = pygame.time.get_ticks()&#10;    dt = max(0.0, (now_ms - last_time_ms) / 1000.0)&#10;    last_time_ms = now_ms&#10;&#10;    screen.fill(BG_COLOR)&#10;&#10;    piano_y_target = piano_y_default if teaching_mode else piano_y_center&#10;    overlay_alpha_target = 1.0 if teaching_mode else 0.0&#10;    sheet_alpha_target = 1.0 if teaching_mode else 0.0&#10;    if dt &gt; 0.0:&#10;        a = 1.0 - math.exp(-dt / max(1e-6, piano_tau))&#10;        piano_y_current += (piano_y_target - piano_y_current) * a&#10;        b = 1.0 - math.exp(-dt / max(1e-6, alpha_tau))&#10;        overlay_alpha_current += (overlay_alpha_target - overlay_alpha_current) * b&#10;        sheet_alpha_current += (sheet_alpha_target - sheet_alpha_current) * b&#10;    dims[&quot;PIANO_Y_OFFSET&quot;] = piano_y_current&#10;    dims[&quot;PEDAL_Y&quot;] = int(piano_y_current + WHITE_KEY_HEIGHT + 30)&#10;    with state_lock:&#10;        pressed_keys_snapshot = dict(pressed_keys)&#10;        pressed_fade_keys_snapshot = dict(pressed_fade_keys)&#10;        pedals_snapshot = dict(pedals)&#10;    draw_piano(&#10;        screen,&#10;        pressed_keys_snapshot,&#10;        pressed_fade_keys_snapshot,&#10;        pedals_snapshot,&#10;        dims,&#10;        midi_teacher.get_next_notes() if teaching_mode else set(),&#10;    )&#10;    draw_ui_overlay(&#10;        screen,&#10;        midi_teacher,&#10;        dims,&#10;        guided_teacher,&#10;        font_small,&#10;        font_medium,&#10;        alpha=overlay_alpha_current,&#10;    )&#10;    if guided_mode and teaching_mode:&#10;        draw_guided_mode_overlay(screen, guided_teacher, sheet_music_renderer, dims)&#10;    sheet_music_renderer.draw(&#10;        screen,&#10;        dims.get(&quot;SHEET_Y&quot;, 0),&#10;        midi_teacher.get_progress(),&#10;        guided_teacher,&#10;        sheet_alpha_current,&#10;    )&#10;&#10;    guided_teacher.render(screen)&#10;&#10;    pygame.display.flip()&#10;&#10;&#10;def midi_listener():&#10;    try:&#10;        port_name = mido.get_input_names()[1]&#10;        print(f&quot;Opening MIDI input: {port_name}&quot;)&#10;    except IndexError:&#10;        print(&quot;No MIDI input found.&quot;)&#10;        return&#10;    with mido.open_input(port_name) as in_port:&#10;            print(msg)&#10;            all_midi_events.append(msg.copy(time=time.time()))&#10;            if msg.type == &quot;note_on&quot; and msg.velocity &gt; 0:&#10;                with state_lock:&#10;                    pressed_keys[msg.note] = True&#10;                    pressed_fade_keys[msg.note] = pygame.time.get_ticks()&#10;                pressed_notes_set.add(msg.note)&#10;                msg.time = time.time()&#10;                if teaching_mode:&#10;                    next_notes = midi_teacher.get_next_notes()&#10;                    if msg.note in next_notes:&#10;                        if synth_enabled:&#10;                            synth.note_on(msg.note, msg.velocity)&#10;                    else:&#10;                        if synth_enabled:&#10;                            synth.play_error_sound()&#10;                    midi_teacher.advance_if_pressed(pressed_notes_set)&#10;                else:&#10;                    if synth_enabled:&#10;                        synth.note_on(msg.note, msg.velocity)&#10;            elif msg.type in (&quot;note_off&quot;, &quot;note_on&quot;):&#10;                with state_lock:&#10;                    pressed_keys[msg.note] = False&#10;                    pressed_fade_keys.pop(msg.note, None)&#10;                pressed_notes_set.discard(msg.note)&#10;                if synth_enabled:&#10;                    synth.note_off(msg.note)&#10;            elif msg.type == &quot;control_change&quot;:&#10;                for pedal, cc in PEDAL_CC.items():&#10;                    if msg.control == cc:&#10;                        with state_lock:&#10;                            pedals[pedal] = msg.value &gt;= 64&#10;                        if synth_enabled:&#10;                            synth.pedal_cc(msg.control, msg.value)&#10;&#10;&#10;def run():&#10;    global \&#10;        teaching_mode, \&#10;        guided_mode, \&#10;        synth_enabled, \&#10;        midi_teacher, \&#10;        guided_teacher, \&#10;        all_midi_events, \&#10;        pressed_notes_set&#10;&#10;    running = True&#10;    while running:&#10;        events = pygame.event.get()&#10;        if guided_mode and teaching_mode:&#10;            guided_teacher.update(pressed_notes_set, all_midi_events, events)&#10;        all_midi_events.clear()&#10;        for event in events:&#10;            if event.type == pygame.QUIT or (&#10;                event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE&#10;            ):&#10;                running = False&#10;            if event.type == pygame.KEYDOWN:&#10;                if event.key == pygame.K_s:&#10;                    synth_enabled = not synth_enabled&#10;                    print(f&quot;Synth enabled: {synth_enabled}&quot;)&#10;                if event.key == pygame.K_t:&#10;                    teaching_mode = not teaching_mode&#10;                    print(f&quot;Teaching mode: {teaching_mode}&quot;)&#10;                    midi_teacher.reset()&#10;                    pressed_notes_set.clear()&#10;                if event.key == pygame.K_g:&#10;                    guided_mode = not guided_mode&#10;                    if guided_mode:&#10;                        teaching_mode = True&#10;                        pressed_notes_set.clear()&#10;                        guided_teacher.start()&#10;                    else:&#10;                        guided_teacher.stop()&#10;                    print(f&quot;Guided mode: {guided_mode}&quot;)&#10;                if event.key == pygame.K_d and teaching_mode:&#10;                    advanced = midi_teacher.advance_one()&#10;                    if advanced:&#10;                        print(&quot;[Debug] Advanced teacher by one chord.&quot;)&#10;                    else:&#10;                        print(&quot;[Debug] Already at end; cannot advance.&quot;)&#10;&#10;                # Seeking controls&#10;                if event.key in (pygame.K_RIGHT, pygame.K_LEFT):&#10;                    # compute step based on modifiers&#10;                    step = 1&#10;                    mods = pygame.key.get_mods()&#10;                    if mods &amp; pygame.KMOD_SHIFT:&#10;                        step = 10&#10;                    elif mods &amp; pygame.KMOD_CTRL:&#10;                        step = 5&#10;                    if event.key == pygame.K_LEFT:&#10;                        step = -step&#10;                    midi_teacher.seek_relative(step)&#10;&#10;                # loop controls: set start/end and toggle&#10;                if event.key == pygame.K_COMMA:  # ','&#10;                    midi_teacher.set_loop_start()&#10;                    ls, le, _ = midi_teacher.get_loop_range()&#10;                    print(f&quot;Set loop start to {ls}&quot;)&#10;                if event.key == pygame.K_PERIOD:  # '.'&#10;                    midi_teacher.set_loop_end()&#10;                    ls, le, _ = midi_teacher.get_loop_range()&#10;                    print(f&quot;Set loop end to {le}&quot;)&#10;                if event.key == pygame.K_l:&#10;                    midi_teacher.toggle_loop()&#10;                    print(f&quot;Loop enabled: {midi_teacher.loop_enabled}&quot;)&#10;&#10;            if event.type == pygame.MOUSEBUTTONDOWN:&#10;                mx, my = event.pos&#10;                bar_height = 28&#10;                bar_margin = 24&#10;                bar_width = int(SCREEN_WIDTH * 0.7)&#10;                bx = int((SCREEN_WIDTH - bar_width) / 2)&#10;                by = bar_margin&#10;                if bx &lt;= mx &lt;= bx + bar_width and by &lt;= my &lt;= by + bar_height:&#10;                    rel = (mx - bx) / float(bar_width)&#10;                    rel = max(0.0, min(1.0, rel))&#10;                    total = midi_teacher.get_total_chords()&#10;                    if total &gt; 0:&#10;                        idx = int(round(rel * (total - 1)))&#10;                    else:&#10;                        idx = 0&#10;&#10;                    mods = pygame.key.get_mods()&#10;                    if event.button == 1 and not (&#10;                        mods &amp; (pygame.KMOD_SHIFT | pygame.KMOD_CTRL)&#10;                    ):&#10;                        midi_teacher.seek_to_progress(rel)&#10;                    elif event.button == 1 and (mods &amp; pygame.KMOD_SHIFT):&#10;                        # shift+left-click: set loop start&#10;                        midi_teacher.set_loop_start_index(idx)&#10;                        ls, le, _ = midi_teacher.get_loop_range()&#10;                        print(f&quot;Set loop start to {ls}&quot;)&#10;                    elif event.button == 1 and (mods &amp; pygame.KMOD_CTRL):&#10;                        # ctrl+left-click: set loop end&#10;                        midi_teacher.set_loop_end_index(idx)&#10;                        ls, le, _ = midi_teacher.get_loop_range()&#10;                        print(f&quot;Set loop end to {le}&quot;)&#10;                    elif event.button == 2:&#10;                        # middle click: set loop start&#10;                        midi_teacher.set_loop_start_index(idx)&#10;                        ls, le, _ = midi_teacher.get_loop_range()&#10;                        print(f&quot;Set loop start to {ls}&quot;)&#10;                    elif event.button == 3:&#10;                        # right-click: set the loop end&#10;                        midi_teacher.set_loop_end_index(idx)&#10;                        ls, le, _ = midi_teacher.get_loop_range()&#10;                        print(f&quot;Set loop end to {le}&quot;)&#10;&#10;                    pressed_notes_set.clear()&#10;&#10;        render()&#10;        clock.tick(60)&#10;&#10;&#10;def main():&#10;    init_app()&#10;&#10;    midi_thread = threading.Thread(target=midi_listener, daemon=True)&#10;    midi_thread.start()&#10;&#10;    run()&#10;&#10;    pygame.quit()&#10;    synth.delete()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Main application module for the Music Teacher application.&#10;&#10;This module serves as the primary entry point for the Music Teacher app.&#10;It initializes the PyGame environment, sets up the components, and runs the main loop.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import pygame&#10;import mido&#10;import threading&#10;import math&#10;from typing import Optional, Dict, Any&#10;from ..ui.visual import draw_piano, draw_ui_overlay, BG_COLOR, draw_guided_mode_overlay&#10;from ..audio.synth import Synth, PEDAL_CC&#10;from .midi_teach import MidiTeacher&#10;from ..ui.sheet_music import SheetMusicRenderer&#10;from .guided_teacher import GuidedTeacher&#10;from ..utils.save_system import SaveSystem&#10;&#10;LOWEST_NOTE = 21  # A0&#10;HIGHEST_NOTE = 108  # C8&#10;TOTAL_KEYS = HIGHEST_NOTE - LOWEST_NOTE + 1&#10;SOUNDFONT_PATH = &quot;/home/u200b/Music/Sound fonts/GeneralUser-GS.sf2&quot;&#10;&#10;# Defer blocking/heavy initialization to init_app()&#10;screen: Optional[pygame.Surface] = None&#10;clock: Optional[pygame.time.Clock] = None&#10;SCREEN_WIDTH: Optional[int] = None&#10;SCREEN_HEIGHT: Optional[int] = None&#10;WHITE_KEY_WIDTH: Optional[float] = None&#10;WHITE_KEY_HEIGHT: Optional[int] = None&#10;BLACK_KEY_WIDTH: Optional[float] = None&#10;BLACK_KEY_HEIGHT: Optional[float] = None&#10;PEDAL_WIDTH: Optional[int] = None&#10;PEDAL_HEIGHT: Optional[int] = None&#10;PEDAL_SPACING: Optional[int] = None&#10;PEDAL_Y: Optional[int] = None&#10;PIANO_Y_OFFSET: Optional[int] = None&#10;SHEET_Y: Optional[int] = None&#10;&#10;pressed_keys: Dict[int, bool] = {}&#10;pressed_fade_keys: Dict[int, int] = {}&#10;pedals: Dict[str, bool] = {&quot;soft&quot;: False, &quot;sostenuto&quot;: False, &quot;sustain&quot;: False}&#10;synth_enabled: bool = True&#10;teaching_mode: bool = True&#10;guided_mode: bool = False&#10;pressed_notes_set: set[int] = set()&#10;all_midi_events: list[Any] = []&#10;&#10;total_keys = TOTAL_KEYS&#10;&#10;piano_y_default: Optional[float] = None&#10;piano_y_center: Optional[float] = None&#10;piano_y_current: Optional[float] = None&#10;piano_y_target: Optional[float] = None&#10;&#10;overlay_alpha_current: Optional[float] = None&#10;overlay_alpha_target: Optional[float] = None&#10;sheet_alpha_current: Optional[float] = None&#10;sheet_alpha_target: Optional[float] = None&#10;piano_tau = 0.12&#10;alpha_tau = 0.18&#10;&#10;last_time_ms: Optional[int] = None&#10;&#10;dims: Dict[str, Any] = {}&#10;&#10;font_small: Optional[pygame.font.Font] = None&#10;font_medium: Optional[pygame.font.Font] = None&#10;&#10;# placeholders for objects that will be created during init&#10;save_system: Optional[SaveSystem] = None&#10;midi_path: Optional[str] = None&#10;state_lock: Optional[threading.Lock] = None&#10;synth: Optional[Synth] = None&#10;sheet_music_renderer: Optional[SheetMusicRenderer] = None&#10;midi_teacher: Optional[MidiTeacher] = None&#10;guided_teacher: Optional[GuidedTeacher] = None&#10;&#10;&#10;def save_all():&#10;    try:&#10;        # Be defensive: save_system and guided_teacher may be None if called before init_app()&#10;        if save_system is None and guided_teacher is None:&#10;            return&#10;        if save_system is not None:&#10;            save_system.save_midi(midi_path)&#10;        if guided_teacher is not None:&#10;            guided_teacher.save_state(force=True)&#10;    except Exception as e:&#10;        print(f&quot;Failed to save state: {e}&quot;)&#10;&#10;&#10;# Move blocking and heavy initialization into this function so module import is fast.&#10;# This sets up pygame, display, fonts, save system (and its MIDI prompt), synth,&#10;# sheet music renderer, midi teacher and guided teacher.&#10;def init_app():&#10;    global screen, clock, SCREEN_WIDTH, SCREEN_HEIGHT&#10;    global WHITE_KEY_WIDTH, WHITE_KEY_HEIGHT, BLACK_KEY_WIDTH, BLACK_KEY_HEIGHT&#10;    global PEDAL_WIDTH, PEDAL_HEIGHT, PEDAL_SPACING, PEDAL_Y, PIANO_Y_OFFSET, SHEET_Y&#10;    global piano_y_default, piano_y_center, piano_y_current, piano_y_target&#10;    global overlay_alpha_current, overlay_alpha_target, sheet_alpha_current, sheet_alpha_target&#10;    global last_time_ms, dims, font_small, font_medium&#10;    global save_system, midi_path, state_lock, synth, sheet_music_renderer, midi_teacher, guided_teacher&#10;&#10;    pygame.init()&#10;    info = pygame.display.Info()&#10;    SCREEN_WIDTH, SCREEN_HEIGHT = info.current_w, info.current_h&#10;    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))&#10;    pygame.display.set_caption(&quot;MIDI Piano Visualizer&quot;)&#10;    clock = pygame.time.Clock()&#10;&#10;    WHITE_KEY_WIDTH = SCREEN_WIDTH / 52&#10;    WHITE_KEY_HEIGHT = int(WHITE_KEY_WIDTH * 7)&#10;    BLACK_KEY_WIDTH = WHITE_KEY_WIDTH * 0.6&#10;    BLACK_KEY_HEIGHT = WHITE_KEY_HEIGHT * 0.65&#10;    PEDAL_WIDTH = int(WHITE_KEY_WIDTH * 1.2)&#10;    PEDAL_HEIGHT = int(WHITE_KEY_HEIGHT * 0.6)&#10;    PEDAL_SPACING = int(WHITE_KEY_WIDTH * 0.2)&#10;    SHEET_Y = 24 + 28 + 64&#10;    PIANO_Y_OFFSET = SHEET_Y + WHITE_KEY_HEIGHT + PEDAL_HEIGHT&#10;    PEDAL_Y = PIANO_Y_OFFSET + WHITE_KEY_HEIGHT + 30&#10;&#10;    piano_y_default = PIANO_Y_OFFSET&#10;    piano_y_center = (SCREEN_HEIGHT - WHITE_KEY_HEIGHT - PEDAL_HEIGHT) // 2&#10;    piano_y_current = float(piano_y_default)&#10;    piano_y_target = float(piano_y_default)&#10;&#10;    overlay_alpha_current = 1.0 if teaching_mode else 0.0&#10;    overlay_alpha_target = overlay_alpha_current&#10;    sheet_alpha_current = 1.0 if teaching_mode else 0.0&#10;    sheet_alpha_target = sheet_alpha_current&#10;&#10;    last_time_ms = pygame.time.get_ticks()&#10;&#10;    dims = {&#10;        &quot;SCREEN_WIDTH&quot;: SCREEN_WIDTH,&#10;        &quot;SCREEN_HEIGHT&quot;: SCREEN_HEIGHT,&#10;        &quot;WHITE_KEY_WIDTH&quot;: WHITE_KEY_WIDTH,&#10;        &quot;WHITE_KEY_HEIGHT&quot;: WHITE_KEY_HEIGHT,&#10;        &quot;BLACK_KEY_WIDTH&quot;: BLACK_KEY_WIDTH,&#10;        &quot;BLACK_KEY_HEIGHT&quot;: BLACK_KEY_HEIGHT,&#10;        &quot;PEDAL_WIDTH&quot;: PEDAL_WIDTH,&#10;        &quot;PEDAL_HEIGHT&quot;: PEDAL_HEIGHT,&#10;        &quot;PEDAL_SPACING&quot;: PEDAL_SPACING,&#10;        &quot;PEDAL_Y&quot;: PEDAL_Y,&#10;        &quot;LOWEST_NOTE&quot;: LOWEST_NOTE,&#10;        &quot;HIGHEST_NOTE&quot;: HIGHEST_NOTE,&#10;        &quot;PIANO_Y_OFFSET&quot;: PIANO_Y_OFFSET,&#10;        &quot;SHEET_Y&quot;: SHEET_Y,&#10;    }&#10;&#10;    font_small = pygame.font.SysFont(&quot;Segoe UI&quot;, 16)&#10;    font_medium = pygame.font.SysFont(&quot;Segoe UI&quot;, 20, bold=True)&#10;&#10;    save_system = SaveSystem(before_exit_callback=save_all)&#10;    midi_path = save_system.load_midi_path() or input(&quot;Enter path to MIDI file: &quot;).strip()&#10;    state_lock = threading.Lock()&#10;&#10;    # Create synth, renderers and teacher objects (may load files / be heavy)&#10;    synth = Synth(SOUNDFONT_PATH, render)&#10;    sheet_music_renderer = SheetMusicRenderer(&#10;        midi_path, SCREEN_WIDTH, save_system=save_system&#10;    )&#10;    midi_teacher = MidiTeacher(midi_path, sheet_music_renderer, save_system=save_system)&#10;    guided_teacher = GuidedTeacher(midi_teacher, synth, save_system=save_system)&#10;&#10;&#10;def render():&#10;    global \&#10;        last_time_ms, \&#10;        piano_y_current, \&#10;        piano_y_target, \&#10;        overlay_alpha_current, \&#10;        overlay_alpha_target, \&#10;        sheet_alpha_current, \&#10;        sheet_alpha_target&#10;&#10;    # If init_app() hasn't been run yet, don't attempt to render.&#10;    if screen is None or last_time_ms is None:&#10;        return&#10;&#10;    now_ms = pygame.time.get_ticks()&#10;    dt = max(0.0, (now_ms - last_time_ms) / 1000.0)&#10;    last_time_ms = now_ms&#10;&#10;    screen.fill(BG_COLOR)&#10;&#10;    piano_y_target = piano_y_default if teaching_mode else piano_y_center&#10;    overlay_alpha_target = 1.0 if teaching_mode else 0.0&#10;    sheet_alpha_target = 1.0 if teaching_mode else 0.0&#10;    if dt &gt; 0.0:&#10;        a = 1.0 - math.exp(-dt / max(1e-6, piano_tau))&#10;        piano_y_current += (piano_y_target - piano_y_current) * a&#10;        b = 1.0 - math.exp(-dt / max(1e-6, alpha_tau))&#10;        overlay_alpha_current += (overlay_alpha_target - overlay_alpha_current) * b&#10;        sheet_alpha_current += (sheet_alpha_target - sheet_alpha_current) * b&#10;    dims[&quot;PIANO_Y_OFFSET&quot;] = piano_y_current&#10;    dims[&quot;PEDAL_Y&quot;] = int(piano_y_current + WHITE_KEY_HEIGHT + 30)&#10;    with state_lock:&#10;        pressed_keys_snapshot = dict(pressed_keys)&#10;        pressed_fade_keys_snapshot = dict(pressed_fade_keys)&#10;        pedals_snapshot = dict(pedals)&#10;    draw_piano(&#10;        screen,&#10;        pressed_keys_snapshot,&#10;        pressed_fade_keys_snapshot,&#10;        pedals_snapshot,&#10;        dims,&#10;        midi_teacher.get_next_notes() if teaching_mode else set(),&#10;    )&#10;    draw_ui_overlay(&#10;        screen,&#10;        midi_teacher,&#10;        dims,&#10;        guided_teacher,&#10;        font_small,&#10;        font_medium,&#10;        alpha=overlay_alpha_current,&#10;    )&#10;    if guided_mode and teaching_mode:&#10;        draw_guided_mode_overlay(screen, guided_teacher, sheet_music_renderer, dims)&#10;    sheet_music_renderer.draw(&#10;        screen,&#10;        dims.get(&quot;SHEET_Y&quot;, 0),&#10;        midi_teacher.get_progress(),&#10;        guided_teacher,&#10;        sheet_alpha_current,&#10;    )&#10;&#10;    guided_teacher.render(screen)&#10;&#10;    pygame.display.flip()&#10;&#10;&#10;def midi_listener():&#10;    try:&#10;        port_name = mido.get_input_names()[1]&#10;        print(f&quot;Opening MIDI input: {port_name}&quot;)&#10;    except IndexError:&#10;        print(&quot;No MIDI input found.&quot;)&#10;        return&#10;    with mido.open_input(port_name) as in_port:&#10;            print(msg)&#10;            all_midi_events.append(msg.copy(time=time.time()))&#10;            if msg.type == &quot;note_on&quot; and msg.velocity &gt; 0:&#10;                with state_lock:&#10;                    pressed_keys[msg.note] = True&#10;                    pressed_fade_keys[msg.note] = pygame.time.get_ticks()&#10;                pressed_notes_set.add(msg.note)&#10;                msg.time = time.time()&#10;                if teaching_mode:&#10;                    next_notes = midi_teacher.get_next_notes()&#10;                    if msg.note in next_notes:&#10;                        if synth_enabled:&#10;                            synth.note_on(msg.note, msg.velocity)&#10;                    else:&#10;                        if synth_enabled:&#10;                            synth.play_error_sound()&#10;                    midi_teacher.advance_if_pressed(pressed_notes_set)&#10;                else:&#10;                    if synth_enabled:&#10;                        synth.note_on(msg.note, msg.velocity)&#10;            elif msg.type in (&quot;note_off&quot;, &quot;note_on&quot;):&#10;                with state_lock:&#10;                    pressed_keys[msg.note] = False&#10;                    pressed_fade_keys.pop(msg.note, None)&#10;                pressed_notes_set.discard(msg.note)&#10;                if synth_enabled:&#10;                    synth.note_off(msg.note)&#10;            elif msg.type == &quot;control_change&quot;:&#10;                for pedal, cc in PEDAL_CC.items():&#10;                    if msg.control == cc:&#10;                        with state_lock:&#10;                            pedals[pedal] = msg.value &gt;= 64&#10;                        if synth_enabled:&#10;                            synth.pedal_cc(msg.control, msg.value)&#10;&#10;&#10;def run():&#10;    global \&#10;        teaching_mode, \&#10;        guided_mode, \&#10;        synth_enabled, \&#10;        midi_teacher, \&#10;        guided_teacher, \&#10;        all_midi_events, \&#10;        pressed_notes_set&#10;&#10;    running = True&#10;    while running:&#10;        events = pygame.event.get()&#10;        if guided_mode and teaching_mode:&#10;            guided_teacher.update(pressed_notes_set, all_midi_events, events)&#10;        all_midi_events.clear()&#10;        for event in events:&#10;            if event.type == pygame.QUIT or (&#10;                event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE&#10;            ):&#10;                running = False&#10;            if event.type == pygame.KEYDOWN:&#10;                if event.key == pygame.K_s:&#10;                    synth_enabled = not synth_enabled&#10;                    print(f&quot;Synth enabled: {synth_enabled}&quot;)&#10;                if event.key == pygame.K_t:&#10;                    teaching_mode = not teaching_mode&#10;                    print(f&quot;Teaching mode: {teaching_mode}&quot;)&#10;                    midi_teacher.reset()&#10;                    pressed_notes_set.clear()&#10;                if event.key == pygame.K_g:&#10;                    guided_mode = not guided_mode&#10;                    if guided_mode:&#10;                        teaching_mode = True&#10;                        pressed_notes_set.clear()&#10;                        guided_teacher.start()&#10;                    else:&#10;                        guided_teacher.stop()&#10;                    print(f&quot;Guided mode: {guided_mode}&quot;)&#10;                if event.key == pygame.K_d and teaching_mode:&#10;                    advanced = midi_teacher.advance_one()&#10;                    if advanced:&#10;                        print(&quot;[Debug] Advanced teacher by one chord.&quot;)&#10;                    else:&#10;                        print(&quot;[Debug] Already at end; cannot advance.&quot;)&#10;&#10;                # Seeking controls&#10;                if event.key in (pygame.K_RIGHT, pygame.K_LEFT):&#10;                    # compute step based on modifiers&#10;                    step = 1&#10;                    mods = pygame.key.get_mods()&#10;                    if mods &amp; pygame.KMOD_SHIFT:&#10;                        step = 10&#10;                    elif mods &amp; pygame.KMOD_CTRL:&#10;                        step = 5&#10;                    if event.key == pygame.K_LEFT:&#10;                        step = -step&#10;                    midi_teacher.seek_relative(step)&#10;&#10;                # loop controls: set start/end and toggle&#10;                if event.key == pygame.K_COMMA:  # ','&#10;                    midi_teacher.set_loop_start()&#10;                    ls, le, _ = midi_teacher.get_loop_range()&#10;                    print(f&quot;Set loop start to {ls}&quot;)&#10;                if event.key == pygame.K_PERIOD:  # '.'&#10;                    midi_teacher.set_loop_end()&#10;                    ls, le, _ = midi_teacher.get_loop_range()&#10;                    print(f&quot;Set loop end to {le}&quot;)&#10;                if event.key == pygame.K_l:&#10;                    midi_teacher.toggle_loop()&#10;                    print(f&quot;Loop enabled: {midi_teacher.loop_enabled}&quot;)&#10;&#10;            if event.type == pygame.MOUSEBUTTONDOWN:&#10;                mx, my = event.pos&#10;                bar_height = 28&#10;                bar_margin = 24&#10;                bar_width = int(SCREEN_WIDTH * 0.7)&#10;                bx = int((SCREEN_WIDTH - bar_width) / 2)&#10;                by = bar_margin&#10;                if bx &lt;= mx &lt;= bx + bar_width and by &lt;= my &lt;= by + bar_height:&#10;                    rel = (mx - bx) / float(bar_width)&#10;                    rel = max(0.0, min(1.0, rel))&#10;                    total = midi_teacher.get_total_chords()&#10;                    if total &gt; 0:&#10;                        idx = int(round(rel * (total - 1)))&#10;                    else:&#10;                        idx = 0&#10;&#10;                    mods = pygame.key.get_mods()&#10;                    if event.button == 1 and not (&#10;                        mods &amp; (pygame.KMOD_SHIFT | pygame.KMOD_CTRL)&#10;                    ):&#10;                        midi_teacher.seek_to_progress(rel)&#10;                    elif event.button == 1 and (mods &amp; pygame.KMOD_SHIFT):&#10;                        # shift+left-click: set loop start&#10;                        midi_teacher.set_loop_start_index(idx)&#10;                        ls, le, _ = midi_teacher.get_loop_range()&#10;                        print(f&quot;Set loop start to {ls}&quot;)&#10;                    elif event.button == 1 and (mods &amp; pygame.KMOD_CTRL):&#10;                        # ctrl+left-click: set loop end&#10;                        midi_teacher.set_loop_end_index(idx)&#10;                        ls, le, _ = midi_teacher.get_loop_range()&#10;                        print(f&quot;Set loop end to {le}&quot;)&#10;                    elif event.button == 2:&#10;                        # middle click: set loop start&#10;                        midi_teacher.set_loop_start_index(idx)&#10;                        ls, le, _ = midi_teacher.get_loop_range()&#10;                        print(f&quot;Set loop start to {ls}&quot;)&#10;                    elif event.button == 3:&#10;                        # right-click: set the loop end&#10;                        midi_teacher.set_loop_end_index(idx)&#10;                        ls, le, _ = midi_teacher.get_loop_range()&#10;                        print(f&quot;Set loop end to {le}&quot;)&#10;&#10;                    pressed_notes_set.clear()&#10;&#10;        render()&#10;        clock.tick(60)&#10;&#10;&#10;def main():&#10;    init_app()&#10;&#10;    midi_thread = threading.Thread(target=midi_listener, daemon=True)&#10;    midi_thread.start()&#10;&#10;    run()&#10;&#10;    pygame.quit()&#10;    synth.delete()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>